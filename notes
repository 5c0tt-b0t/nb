#!/usr/bin/env bash
#              _
#  _ __   ___ | |_ ___  ___
# | '_ \ / _ \| __/ _ \/ __|
# | | | | (_) | ||  __/\__ \
# |_| |_|\___/ \__\___||___/
#
# Based on Bash Boilerplate: https://github.com/alphabetum/bash-boilerplate
#
# Copyright (c) 2015 William Melody • hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

_VERSION="0.0.0-alpha"

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  %s " "${__DEBUG_COUNTER}"
    "$@"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "$@"
}

###############################################################################
# Help
###############################################################################

# _print_help()
#
# Usage: _print_help
#
# Print the program help information.
_print_help() {
  cat <<HEREDOC
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

Usage:
  $_ME add [<note>]
  $_ME delete ( <index> | <filename> )
  $_ME edit ( <index> | <filename> )
  $_ME init [<remote url>]
  $_ME list [-e | --excerpt [<length>]]
  $_ME log
  $_ME search <query>
  $_ME show ( <index> | <filename> ) [--dump]
  $_ME sync
  $_ME -h | --help | help
  $_ME --version

Subcommands:
  add      Add a new note.
  delete   Delete a note.
  edit     Edit a note.
  help     Display this help information.
  init     Initialize the local notes repository.
  list     List all notes. Optionally, an excerpt of each note can be printed.
  log      Display git history using \`tig\` (if available) or \`git log\`.
  search   Search notes.
  show     Show a note.
  sync     Sync notes with the remote repository.

Options:
  --dump                   Print to standard output.
  -e --excerpt [<length>]  Print an excerpt from each note with an optional
                           length in number of lines [default: 3].
  -h --help                Display this help information.
  --version                Display version information.
HEREDOC
}

###############################################################################
# Version
###############################################################################

# _print_version()
#
# Usage: _print_version
#
# Print the value of $_VERSION.
_print_version() {
  printf "%s\n" "$_VERSION"
}

###############################################################################
# Options
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#))
do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("$1")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_ARGUMENTS=("$0")

# _require_argument()
#
# Usage:
#  _require_argument "$opt" "$_value_variable"
#
# Checks if an value has been set to the expected variable and, if not, prints
# and error message and exits with status 1.
_require_argument() {
  local option="$1"
  local value="$2"

  if [[ -z "$value" ]]
  then
    _die printf "Option requires an argument: %s\n" "$option"
  fi
}
# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while [ $# -gt 0 ]
do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    add|delete|edit|env|help|init|list|log|ls|search|show|sync)
      if [[ -z "${_SUBCOMMAND:-}" ]]
      then
        _SUBCOMMAND="$opt"
      else
        _ARGUMENTS+=("$opt")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      _ARGUMENTS+=("$opt")
      ;;
  esac
done

# Set `$_SUBCOMMAND` if it's still blank.
if [[ -z "${_SUBCOMMAND:-}" ]]
then
  _SUBCOMMAND="help"
fi

_debug printf "\$_SUBCOMMAND: %s\n" "$_SUBCOMMAND"
_debug printf "\$_ARGUMENTS: %s\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# Setup
###############################################################################

# `$NOTES_DIR`
#
# Default: `$HOME/.notes`
export NOTES_DIR="${NOTES_DIR:-${HOME}/.notes}"

# `$NOTES_DATA_DIR`
#
# Default: `$NOTES_DIR/data`
export NOTES_DATA_DIR="${NOTES_DATA_DIR:-${NOTES_DIR}/data}"

# `$NOTES_AUTO_SYNC`
#
# Default: 0
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`.
export NOTES_AUTO_SYNC="${NOTES_AUTO_SYNC:-0}"

###############################################################################
# Helpers
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "$1" 2>/dev/null
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message>
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  local _message="${1:-}"
  if [[ -z "${_message}" ]]
  then
    _die printf "Usage: _git_checkpoint <message>\n"
    return 1
  fi

  cd "${NOTES_DATA_DIR}" || return 1
  git add --all && git commit -a -m "${_message}"

  if ((NOTES_AUTO_SYNC))
  then
    $_ME sync
  fi
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_die` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _die printf "\`git\` is required, but wasn't found.\n"
  fi
}

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

# _add()
#
# Usage:
#   _add <content>
#   echo <content> | _add
_add() {
  # Assign filename with unicode timestamp.
  local _basename
  _basename="$(date -u "+%Y%m%d%H%M%S").md"
  local _filename
  _filename="${NOTES_DATA_DIR}/${_basename}"

  if _interactive_input
  then # terminal input.
    if [[ -z "${*}" ]]
    then # argument array is blank.
      "${EDITOR}" "${_filename}"
    else
      printf "%s\n" "${*}" >> "${_filename}"
    fi
  else # piped input.
    cat >> "${_filename}"
  fi
  _git_checkpoint "[NOTES] Add: ${_basename}"
}

# delete ######################################################################

# _delete()
#
# Usage:
#   _delete <selection>
_delete() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_delete() \$_selection: %s\n" "${_selection}"

  if [[ -z "${_selection}" ]]
  then  # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
    cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\n"
    git rm "${_basename}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))

    _debug printf "_delete() \$_filenames[*]: %s\n" "${_filenames[*]}"

    _basename="${_filenames[${_selection}]:-}"

    if [[ -n "$_basename" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then # _basename is assigned and a note exists with that name.
      cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\n"
      git rm "${_basename}"
    else
      _die printf "Selection not found.\n"
    fi
  else
    _die printf "Selection not found.\n"
  fi

  if [[ -n "${_basename}" ]]
  then
    _git_checkpoint "[NOTES] Delete: ${_basename}"
  fi
}

# edit ########################################################################

# _edit()
#
# Usage:
#   _edit <selection>
_edit() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_edit() \$_selection: %s\n" "${_selection}"

  if [[ -z "${_selection}" ]]
  then # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
    "$EDITOR" "${NOTES_DATA_DIR}/${_basename}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))

    _debug printf "_edit() \$_filenames[*]: %s\n" "${_filenames[*]}"

    _basename="${_filenames[${_selection}]:-}"

    if [[ -n "$_basename" ]] || [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then # _basename is assigned and a note exists with that name.
      "$EDITOR" "${NOTES_DATA_DIR}/${_basename}"
    else
      _die printf "Selection not found.\n"
    fi
  else
    _die printf "Selection not found.\n"
  fi

  if [[ -n "${_basename}" ]]
  then
    _git_checkpoint "[NOTES] Edit: ${_basename}"
  fi
}

# env #############################################@###########################

# _env()
#
# Usage:
#   _env
_env() {
  printf "NOTES_DIR=%s\n" "$NOTES_DIR"
  printf "NOTES_DATA_DIR=%s\n" "$NOTES_DATA_DIR"
  printf "NOTES_AUTO_SYNC=%s\n" "$NOTES_AUTO_SYNC"
}

# list ########################################################################

# _init()
#
# Usage:
#   _init [<repository URL>]
_init() {
  if [[ -e "${NOTES_DIR}" ]]
  then
    _die printf "%s already exists.\n" "${NOTES_DIR}"
  elif [[ -e "${NOTES_DATA_DIR}" ]]
  then
    _die printf "%s already exists.\n" "${NOTES_DATA_DIR}"
  fi

  local _repo_url="${1:-}"
  if [[ -n "${_repo_url}" ]]
  then
    git clone "${_repo_url}" "${NOTES_DATA_DIR}"
  else
    mkdir -p "${NOTES_DATA_DIR}"
    cd "${NOTES_DATA_DIR}" && git init
  fi
}

# list ########################################################################

# _list()
#
# Usage:
#   _list [--excerpt [<lines>]]
_list() {
  _debug printf "_list() \$1: %s\n" "${1:-}"
  _debug printf "_list() \$2: %s\n" "${2:-}"
  _debug printf "_list() \$3: %s\n" "${3:-}"

  local _print_excerpt=0
  local _excerpt_length=3
  if [[ "${1:-}" = "--excerpt" ]] || [[ "${1:-}" = "-e" ]]
  then
    _print_excerpt=1
    if [[ -n "${2:-}" ]]
    then
      _excerpt_length="${2}"
    fi
  fi
  _debug printf "_list() \$_excerpt_length: %s\n" "${_excerpt_length:-}"

  local _filenames=
  _filenames="$(ls -r "${NOTES_DATA_DIR}")"

  if [[ -z "${_filenames}" ]]
  then
    return 1
  else
    local _counter=0
    for _basename in $_filenames
    do
      # Set counter color to yellow.
      local _counter_item
      _counter_item="[$(tput setaf 3)${_counter}$(tput sgr0)]"
      # Maintain a raw version of the counter.
      local _raw_counter_item="[${_counter}]"

      local _file_list_item="${_counter_item} ${_basename}"
      local _raw_file_list_item="${_raw_counter_item} ${_basename}"
      printf "%s\n" "${_file_list_item}"

      if ((_print_excerpt))
      then
        # Print a line. More information:
        # http://wiki.bash-hackers.org/commands/builtin/printf
        local _file_list_item_length=0
        # Use length from `$_raw_file_list_item` because `$_file_list_item`'s
        # `tput` calls increase the measured length.
        _file_list_item_length=${#_raw_file_list_item}
        printf -v line '%*s' "$_file_list_item_length"
        echo "${line// /-}"

        if [[ "${_excerpt_length}" =~ ^[1-9] ]]
        then # first character is a non-zero digit, as required by `head`.
          head -"${_excerpt_length}" "${NOTES_DATA_DIR}/${_basename}"
        fi

        printf "\n"
      fi
      _counter=$((_counter+1))
    done
  fi
}

# log #########################################################################

# _log()
#
# Usage:
#   _log
_log() {
  cd "${NOTES_DATA_DIR}" || _die printf "_history() \`cd\` failed.\n"
  if _command_exists "tig"
  then #  tig (https://github.com/jonas/tig) is present.
    tig --all
  else
    git log
  fi
}

# ls ##########################################################################

# _ls()
#
# Usage:
#   _ls [<excerpt length>]
_ls() {
  $_ME list --excerpt "${1:-}"
}

# search ######################################################################

# _search()
#
# Usage:
#   _search <query>
_search() {
  if [[ -z "${1:-}" ]]
  then
    $_ME help
    return 1
  else
    if _command_exists "ack"
    then # ack is available.
      ack "${@}" "${NOTES_DATA_DIR}"
    else # fall back to POSIX grep.
      # Add /dev/null so file path is printed even if there is only one
      # matching file. Reference: http://stackoverflow.com/a/15432718
      grep -n "${@}" "${NOTES_DATA_DIR}"/* /dev/null
    fi
  fi
}

# show ########################################################################

# _show()
#
# Usage:
#   _show <selection>
_show() {
  _debug printf "_show() \$0: %s\n" "${0:-}"
  _debug printf "_show() \$1: %s\n" "${1:-}"
  _debug printf "_show() \$2: %s\n" "${2:-}"

  local -a _arguments=("${@:1}")
  local _selection=
  local _basename=
  local _render=0
  local _dump=0

  _debug printf "_show() \$_arguments[*]: %s\n" "${_arguments[*]:-}"

  for _arg in "${_arguments[@]:-}"
  do
    case "${_arg}" in
      --dump)
        _dump=1
        ;;
      --render)
        _render=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${_arg}"
        fi
        ;;
    esac
  done

  _debug printf "_show() \$_render: %s\n" "${_render}"
  _debug printf "_show() \$_selection: %s\n" "${_selection}"

  # Determine file basename for the provided <selection>.
  if [[ -z "${_selection}" ]]
  then # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))
    _debug printf "_show() \$_filenames[*]: %s\n" "${_filenames[*]}"
    _basename="${_filenames[${_selection}]:-}"
  fi

  # Display file.
  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    if ((_render)) &&
       ((_dump))   &&
       _command_exists "pandoc" &&
       _command_exists "w3m"
    then # `notes show --render --dump` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "lynx"
    then # `notes show --render` with `pandoc` and `lynx` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" | lynx -stdin
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html \
        | "${PAGER}"
    else # default
      if ((_dump))
      then # `notes show --dump`
        cat "${NOTES_DATA_DIR}/${_basename}"
      else # `notes show`
        "$PAGER" "${NOTES_DATA_DIR}/${_basename}"
      fi
    fi
  else # _basename is not assigned or no note exists with that name.
    _die printf "Selection not found.\n"
  fi
}

# sync ########################################################################

# _sync()
#
# Usage:
#   _sync
_sync() {
  cd "${NOTES_DATA_DIR}" || _die printf "_synd(): cd failed.\n"
  git fetch && git rebase origin/master && git push
}

###############################################################################
# _notes()
###############################################################################

# _notes()
#
# Description:
#   Call the appropriate subcommand.
_notes() {
  _debug printf "_notes() >> start\n"

  case "$_SUBCOMMAND" in
    init)
      _git_required
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
    add|delete|edit|env|list|log|ls|search|show|sync)
      _git_required
      if [[ ! -e "${NOTES_DATA_DIR}" ]]
      then # `$NOTES_DATA_DIR` doesn't exist.
        _die cat <<HEREDOC
$NOTES_DATA_DIR doesn't exist. Use \`$_ME init\` to get started.
Usage: $_ME init [<remote url>]
HEREDOC
      fi
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
    "help")
      _print_help
      ;;
  esac
}

###############################################################################
# Main
###############################################################################

_main() {
  if (("$_PRINT_HELP"))
  then
    _print_help
  elif (("$_PRINT_VERSION"))
  then
    _print_version
  else
    _notes "${_ARGUMENTS[@]:-}"
  fi
}

_main "$@"
