#!/usr/bin/env bash
#              _
#  _ __   ___ | |_ ___  ___
# | '_ \ / _ \| __/ _ \/ __|
# | | | | (_) | ||  __/\__ \
# |_| |_|\___/ \__\___||___/
#
# Based on Bash Boilerplate: https://github.com/alphabetum/bash-boilerplate
#
# Copyright (c) 2015 William Melody • hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

###############################################################################
# Environment
###############################################################################

_VERSION="0.0.0-alpha"

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

# extglob
#
# Enable extended pattern matching operators.
#
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
shopt -s extglob

###############################################################################
# .notesrc
###############################################################################

# .notesrc
#
# If a `.notesrc` file exists in `$HOME`, source it.
if [[ -e "$HOME/.notesrc" ]]
then
  source "$HOME/.notesrc"
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
__DEBUG_COUNTER=0
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]
  then
    __DEBUG_COUNTER=$((__DEBUG_COUNTER+1))
    # Prefix debug message with "bug (U+1F41B)"
    printf "🐛  %s " "${__DEBUG_COUNTER}"
    "$@"
    printf "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
  fi
}
# debug()
#
# Usage:
#   debug "Debug info. Variable: $0"
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "❌  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Usage:
#   die "Error message. Variable: $0"
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
die() {
  _die echo "$@"
}

###############################################################################
# Setup
###############################################################################

# `$NOTES_DIR`
#
# Default: `$HOME/.notes`
export NOTES_DIR="${NOTES_DIR:-${HOME}/.notes}"

# `$NOTES_DATA_DIR`
#
# Default: `$NOTES_DIR/data`
export NOTES_DATA_DIR="${NOTES_DATA_DIR:-${NOTES_DIR}/data}"

# `$NOTES_AUTO_SYNC`
#
# Default: 0
#
# When set to '1', each `_git_checkpoint()` call will automativally run
# `$_ME sync`.
export NOTES_AUTO_SYNC="${NOTES_AUTO_SYNC:-0}"

###############################################################################
# Helpers
###############################################################################

# _command_exists()
#
# Usage:
#   _command_exists "possible_command_name"
#
# Takes a potential command name as an argument and returns whether a command
# exists with that name.
#
# For information on why `hash` is used here, see:
# http://stackoverflow.com/a/677212
_command_exists() {
  hash "$1" 2>/dev/null
}

# _get_index()
#
# Usage:
#   _get_index <item> <list>
#
# Description:
#   Print the index of <item> in <list>
#
# Returns:
#   0  <item> is found in <list>.
#   1  <item> is not found in <list>.
_get_index() {
  _debug printf "_get_index() \${1}: '%s'\n" "${1:-}"
  _debug printf "_get_index() \${@:2}: '%s'\n" "${@:2}"

  local _filename="${1:-}"
  local -a _files=(${@:2})

  _debug printf "_get_index() \${_files[@]}: '%s'\n" "${_files[@]}"

  if [[ -z "${_filename}" ]] || [[ -z "${_files}" ]]
  then
    _die printf "Usage: _get_index <item> <list>"
  fi

  for _i in "${!_files[@]}"
  do
    _debug printf "_get_index() \${_files[$_i]} : '%s'\n" "${_files[$_i]}"
    if [[ "${_files[$_i]}" == "${_filename}" ]]
    then
      printf "%s\n" "${_i}"
      return 0
    fi
  done
  return 1
}

# _git_checkpoint()
#
# Usage:
#   _git_checkpoint <commit message>
#
# Description:
#   Commit all files in the repository with the provided commit message.
_git_checkpoint() {
  _git_checkpoint_commit() {
    [[ -z "${1:-}" ]] && _die printf "Usage: _git_checkpoint_commit <message>"
    git add --all && git commit -a -m "${1}"
  }
  _git_checkpoint_sync() {
    git fetch && git rebase origin/master && git push
  }

  local _message="${1:-}"
  local _show_spinner=0

  if [[ -z "${_message}" ]]
  then
    _die printf "Usage: _git_checkpoint <message>\n"
    return 1
  fi

  if [[ -n "${2:-}" ]] && [[ "${2}" == "--spinner" ]]
  then
    _show_spinner=1
  fi

  cd "${NOTES_DATA_DIR}" || _die printf "_git_checkpoint() \`cd\` failed.\n"

  if ((NOTES_AUTO_SYNC))
  then
    (
      _git_checkpoint_commit "${_message}" &>/dev/null &&
      _git_checkpoint_sync &>/dev/null
    ) &
  else
    (
      _git_checkpoint_commit "${_message}" &>/dev/null
    ) &
  fi

  if ((_show_spinner))
  then
    _spinner $!
  fi
}

# _git_is_dirty()
#
# Usage:
#   _git_is_dirty
#
# Returns:
#   0  If there are uncommitted changes in the `NOTES_DATA_DIR` repository.
#   1  If the `$NOTES_DATA_DIR` repository is clean.
_git_is_dirty() {
  cd "${NOTES_DATA_DIR}" || _die printf "_git_is_dirty() \`cd\` failed.\n"
  [[ -n "$(git status --porcelain)" ]]
}

# _git_required()
#
# Usage:
#   _git_required
#
# Description:
#   Exit with `_die` if `git` isn't found.
_git_required() {
  if ! _command_exists "git"
  then
    _die printf "\`git\` is required, but wasn't found.\n"
  fi
}

# _highlight_syntax_if_available()
#
# Usage:
#   _highlight_syntax_if_available
#
# Description:
#   If Pygments and pygments-markdown-lexer are available, use them to
#   highlight markdown syntax. When they are not available, just pipe through
#   `cat`.
#
# References:
#   http://pygments.org/
#   https://github.com/jhermann/pygments-markdown-lexer
_highlight_syntax_if_available() {
  if hash "pygmentize" 2>/dev/null &&
    pygmentize -l markdown &>/dev/null /dev/null
  then # pygments and the markdown lexer are installed.
    pygmentize -l markdown
  else
    cat
  fi
}

# _interactive_input()
#
# Usage:
#   _interactive_input
#
# Returns:
#   0  If the current input is interactive (eg, a shell).
#   1  If the current input is stdin / piped input.
_interactive_input() {
  [[ -t 0 ]]
}

# _join()
#
# Usage:
#   _join <separator> <array>
#
# Examples:
#   _join , a "b c" d     => a,b c,d
#   _join / var local tmp => var/local/tmp
#   _join , "${FOO[@]}"   => a,b,c
#
# More Information:
#   http://stackoverflow.com/a/17841619
_join() {
  local IFS="$1"
  shift
  printf "%s\n" "$*"
}

# _print_line()
#
# Usage:
#   _print_line <text>
#
# Description:
#   Print a line of dashes the length of <text>.
#
# More information:
#   http://wiki.bash-hackers.org/commands/builtin/printf
_print_line() {
  local _text="${1:-}"
  local _text_length=0
  _text_length=${#_text}
  printf -v line '%*s' "$_text_length"
  echo "${line// /-}"
}

# _spinner()
#
# Usage:
#   _spinner <pid>
#
# Description:
#   Display an ascii spinner while <pid> is running.
#
# Example Usage:
#   ```
#   _spinner_example() {
#     printf "Working..."
#     (sleep 1) &
#     _spinner $!
#     printf "Done!\n"
#   }
#   (_spinner_example)
#   ```
#
# More Information:
#   http://fitnr.com/showing-a-bash-spinner.html
_spinner() {
  local _pid="${1:-}"
  local _delay=0.75
  local _spin_string='|/-\'

  if [[ -z "${_pid}" ]]
  then
    _die printf "Usage: _spinner <pid>\n"
  fi

  while [[ "$(ps a | awk '{print $1}' | grep ${_pid})" ]]
  do
    local _temp="${_spin_string#?}"
    printf " [%c]  " "$_spin_string"
    _spin_string="$_temp${_spin_string%"$_temp"}"
    sleep $_delay
    printf "\b\b\b\b\b\b"
  done
  printf "    \b\b\b\b"
}

###############################################################################
# Options
###############################################################################

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#))
do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++))
      do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]
        then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*)
      options+=("${1%%=*}" "${1#*=}")
      ;;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *)
      options+=("$1")
      ;;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize program option variables.
_PRINT_HELP=0
_PRINT_VERSION=0
_USE_DEBUG=0

# Initialize additional expected option variables.
_SUBCOMMAND=
_ARGUMENTS=("$0")

# $_SUBCOMMANDS
#
# All available subcommands.
_SUBCOMMANDS=(
  add
  delete
  edit
  env
  git
  help
  init
  list
  log
  ls
  search
  show
  status
  sync
  version
)

# $_SUBCOMMANDS_PATTERN
#
# The contents of the `$_SUBCOMMANDS` array, joined with '|', with the
# `@(<pattern list>)` pattern matching operator, which matches one of the
# given patterns. This operator is enabled using `shopt -s extglob`.
#
# More information:
# http://stackoverflow.com/a/13254908
# https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
_SUBCOMMANDS_PATTERN="@($(_join '|' "${_SUBCOMMANDS[@]}"))"

# _require_argument()
#
# Usage:
#  _require_argument "$opt" "$_value_variable"
#
# Checks if an value has been set to the expected variable and, if not, prints
# and error message and exits with status 1.
_require_argument() {
  local option="$1"
  local value="$2"

  if [[ -z "$value" ]]
  then
    _die printf "Option requires an argument: %s\n" "$option"
  fi
}
# getopts and getopts have inconsistent behavior, so using a simple home-brewed
# while loop. This isn't perfectly compliant with POSIX, but it's close enough
# and this appears to be a widely used approach.
#
# More info:
#   http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
#   http://stackoverflow.com/a/14203146
#   http://stackoverflow.com/a/7948533
while [ $# -gt 0 ]
do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      _PRINT_HELP=1
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    --version)
      _PRINT_VERSION=1
      ;;
    $_SUBCOMMANDS_PATTERN)
      if [[ -z "${_SUBCOMMAND:-}" ]]
      then
        _SUBCOMMAND="$opt"
      else
        _ARGUMENTS+=("$opt")
      fi
      ;;
    --endopts)
      # Terminate option parsing.
      break
      ;;
    *)
      _ARGUMENTS+=("$opt")
      ;;
  esac
done

# Set `$_SUBCOMMAND` if it's still blank.
if [[ -z "${_SUBCOMMAND:-}" ]]
then
  _SUBCOMMAND="help"
fi

_debug printf "\$_SUBCOMMANDS[*]: '%s'\n" "${_SUBCOMMANDS[*]}"
_debug printf "\$_SUBCOMMANDS_PATTERN: '%s'\n" "${_SUBCOMMANDS_PATTERN}"
_debug printf "\$_SUBCOMMAND: '%s'\n" "$_SUBCOMMAND"
_debug printf "\$_ARGUMENTS: '%s'\n" "${_ARGUMENTS[*]:-}"

###############################################################################
# Subcommands
###############################################################################

# add #########################################################################

# _add()
#
# Usage:
#   _add <content>
#   echo <content> | _add
_add() {
  # Assign filename with unicode timestamp.
  local _basename
  _basename="$(date -u "+%Y%m%d%H%M%S").md"
  local _filename
  _filename="${NOTES_DATA_DIR}/${_basename}"

  if _interactive_input
  then # terminal input.
    if [[ -z "${*}" ]]
    then # argument array is blank.
      "${EDITOR}" "${_filename}"
    else
      printf "%s\n" "${*}" >> "${_filename}"
    fi
  else # piped input.
    cat >> "${_filename}"
  fi
  _git_checkpoint "[NOTES] Add: ${_basename}"
}

# delete ######################################################################

# _delete()
#
# Usage:
#   _delete <selection>
_delete() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_delete() \$_selection: '%s'\n" "${_selection}"

  if [[ -z "${_selection}" ]]
  then  # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
    cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\n"
    git rm "${_basename}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))

    _debug printf "_delete() \$_filenames[*]: '%s'\n" "${_filenames[*]}"

    _basename="${_filenames[${_selection}]:-}"

    if [[ -n "$_basename" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then # _basename is assigned and a note exists with that name.
      cd "${NOTES_DATA_DIR}" || _die printf "_delete() \`cd\` failed.\n"
      git rm "${_basename}"
    else
      _die printf "Selection not found.\n"
    fi
  else
    _die printf "Selection not found.\n"
  fi

  if [[ -n "${_basename}" ]]
  then
    _git_checkpoint "[NOTES] Delete: ${_basename}"
  fi
}

# edit ########################################################################

# _edit()
#
# Usage:
#   _edit <selection>
_edit() {
  local _selection="${1:-}"
  local _basename=

  _debug printf "_edit() \$_selection: %s\n" "${_selection}"

  if [[ -z "${_selection}" ]]
  then # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
    "$EDITOR" "${NOTES_DATA_DIR}/${_basename}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))

    _debug printf "_edit() \$_filenames[*]: '%s'\n" "${_filenames[*]}"

    _basename="${_filenames[${_selection}]:-}"

    if [[ -n "$_basename" ]] || [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
    then # _basename is assigned and a note exists with that name.
      "$EDITOR" "${NOTES_DATA_DIR}/${_basename}"
    else
      _die printf "Selection not found.\n"
    fi
  else
    _die printf "Selection not found.\n"
  fi

  if [[ -n "${_basename}" ]]
  then
    _git_checkpoint "[NOTES] Edit: ${_basename}"
  fi
}

# env #############################################@###########################

# _env()
#
# Usage:
#   _env
_env() {
  printf "NOTES_DIR=%s\n" "$NOTES_DIR"
  printf "NOTES_DATA_DIR=%s\n" "$NOTES_DATA_DIR"
  printf "NOTES_AUTO_SYNC=%s\n" "$NOTES_AUTO_SYNC"
}

# git #############################################@###########################

# _git()
#
# Usage:
#   _git <arguments>
_git() {
  cd "${NOTES_DATA_DIR}" || _die printf "_git() \`cd\` failed.\n"
  git "${@}"
}

# help ########################################################################

# _help()
#
# Usage: _help
#
# Print the program help information.
_help() {
  cat <<HEREDOC
             _
 _ __   ___ | |_ ___  ___
| '_ \ / _ \| __/ _ \/ __|
| | | | (_) | ||  __/\__ \\
|_| |_|\___/ \__\___||___/

Usage:
  $_ME add [<note>]
  $_ME delete (<index> | <filename>)
  $_ME edit (<index> | <filename>)
  $_ME init [<remote url>]
  $_ME list ([-e | --excerpt [<length>]] | [--noindex])
  $_ME ls
  $_ME log
  $_ME search <query> [--path]
  $_ME show (<index> | <filename>) ([--dump] | [--path])
  $_ME sync
  $_ME -h | --help | help
  $_ME --version | version

Subcommands:
  add      Add a new note.
  delete   Delete a note.
  edit     Edit a note.
  help     Display this help information.
  init     Initialize the local notes repository.
  list     List all notes. Optionally, an excerpt of each note can be printed.
  ls       List with an excerpt. This is an alias for \`$_ME list -e\`.
  log      Display git history using \`tig\` (if available) or \`git log\`.
  search   Search notes.
  show     Show a note.
  sync     Sync notes with the remote repository.
  version  Display version information.

Options:
  --dump                 Print to standard output.
  -e --excerpt <length>  Print an excerpt from each note with an optional
                         length in number of lines [default: 3].
  -h --help              Display this help information.
  --noindex              Don't print the index number for each listing.
  --path                 Print the absolute path to the note file.
  --version              Display version information.
HEREDOC
}

# init ########################################################################

# _init()
#
# Usage:
#   _init [<repository URL>]
_init() {
  if [[ -e "${NOTES_DIR}" ]]
  then
    _die printf "%s already exists.\n" "${NOTES_DIR}"
  elif [[ -e "${NOTES_DATA_DIR}" ]]
  then
    _die printf "%s already exists.\n" "${NOTES_DATA_DIR}"
  fi

  local _repo_url="${1:-}"
  if [[ -n "${_repo_url}" ]]
  then
    git clone "${_repo_url}" "${NOTES_DATA_DIR}"
  else
    mkdir -p "${NOTES_DATA_DIR}"
    cd "${NOTES_DATA_DIR}" && git init
  fi
}

# list ########################################################################

# _list()
#
# Usage:
#   _list [--excerpt [<lines>]]
_list() {
  _debug printf "_list() \$1: '%s'\n" "${1:-}"
  _debug printf "_list() \$2: '%s'\n" "${2:-}"
  _debug printf "_list() \$3: '%s'\n" "${3:-}"

  local _print_excerpt=0
  local _excerpt_length=3
  local _noindex=0

  _debug printf "_list() \$@: '%s'\n" "${@:-}"

  # Parse function options.
  while (($#))
  do
    # __option_value_is_present()
    #
    # Usage:
    #   __option_value_is_present "${variable}"
    #
    # Returns:
    #   0  The argument is blank or matches as an option flag.
    #   1  The argument is present and does not match an option flag.
    __option_value_is_present() {
      [[ -n "${1:-}" ]] && [[ ! "${1:-}" =~ ^- ]]
    }
    local _arg="${1:-}"
    local _val="${2:-}"
    case "$_arg" in
      -e|--excerpt)
        _print_excerpt=1
        if __option_value_is_present "${_val:-}"
        then
          _excerpt_length="${_val:-}"
          shift
        fi
        ;;
      --noindex)
        _noindex=1
        ;;
      *)
        _debug printf "_list() *: '%s'\n" "${_arg:-}"
        ;;
    esac
    shift
  done

  _debug printf "_list() \$_print_excerpt: '%s'\n" "${_print_excerpt:-}"
  _debug printf "_list() \$_excerpt_length: '%s'\n" "${_excerpt_length:-}"

  local _filenames=
  _filenames="$(ls -r "${NOTES_DATA_DIR}")"

  if [[ -z "${_filenames}" ]]
  then # no files in `$NOTES_DATA_DIR`
cat <<HEREDOC
0 notes.

Add a note:
  $_ME add
Usage information:
  $_ME help
HEREDOC
    return 1
  else
    local _counter=0
    for _basename in $_filenames
    do
      # NOTE: Plain version serves as the reference version and can be used
      # for length calculations.
      local _counter_item="[${_counter}]"
      local _counter_item_color
      _counter_item_color="[$(tput setaf 3)${_counter}$(tput sgr0)]"

      local _list_item="${_counter_item} ${_basename}"
      local _list_item_color="${_counter_item_color} ${_basename}"

      if ((_noindex))
      then
        printf "%s\n" "${_basename}"
      else
        printf "%s\n" "${_list_item_color}"
      fi

      if ((_print_excerpt))
      then
        _print_line "${_list_item}"

        if [[ "${_excerpt_length}" =~ ^[1-9] ]]
        then # first character is a non-zero digit, as required by `head`.
          head -"${_excerpt_length}" "${NOTES_DATA_DIR}/${_basename}" \
            | _highlight_syntax_if_available
        fi

        printf "\n"
      fi
      _counter=$((_counter+1))
    done
  fi
}

# log #########################################################################

# _log()
#
# Usage:
#   _log
_log() {
  cd "${NOTES_DATA_DIR}" || _die printf "_history() \`cd\` failed.\n"
  if _command_exists "tig"
  then #  tig (https://github.com/jonas/tig) is present.
    tig --all
  else
    git log
  fi
}

# ls ##########################################################################

# _ls()
#
# Usage:
#   _ls [<excerpt length>]
_ls() {
  $_ME list --excerpt "${1:-}"
}

# search ######################################################################

# _search()
#
# Usage:
#   _search <query>
_search() {
  local _arguments=("${@:1}")
  local _query=
  local _print_paths=0
  local _last_path=

  for _arg in "${_arguments[@]:-}"
  do
    case "${_arg}" in
      --path)
        _print_paths=1
        ;;
      *)
        if [[ -z "${_query}" ]]
        then
          _query="${_arg}"
        fi
        ;;
    esac
  done

  if [[ -z "${_query:-}" ]]
  then
    $_ME help
    return 1
  else
    local _files=
    _files=($($_ME list --noindex))

    if _command_exists "ack"
    then # ack is available.
      ack "${_query}" "${NOTES_DATA_DIR}" \
        --ignore-case \
        --noheading \
        --color-lineno='bold green' \
        --color-match='black on_blue'
    else # fall back to POSIX grep.
      # Add /dev/null so file path is printed even if there is only one
      # matching file. Reference: http://stackoverflow.com/a/15432718
      grep --ignore-case -n "${_query}" "${NOTES_DATA_DIR}"/* /dev/null
    fi | while read -r _line
    do
      local _path=
      local _filename=
      local _index=
      local _indexed_filename=
      local _hit=

      # Use `sed` to remove color from output.
      # http://unix.stackexchange.com/a/140255
      _path="$(
        printf "%s\n" "${_line}" \
          | cut -d: -f 1 \
          | sed "s,$(printf '\033')\\[[0-9;]*[a-zA-Z],,g"
      )"

      if ((_print_paths))
      then
        if [[ "${_last_path}" != "${_path}" ]]
        then # match is in a different file than the last match
          printf "%s\n" "${_path}"
        fi
      else
        _filename="$(basename "${_path}")"
        _index="$(_get_index "${_filename}" "${_files[@]}")"
        _indexed_filename="[$(tput setaf 3)${_index}$(tput sgr0)] ${_filename}"

        if [[ "${_last_path}" != "${_path}" ]]
        then # match is in a different file than the last match
          printf "%s\n" "${_indexed_filename}"
          # Use `[${_i}]` to avoid additional length from `tput` calls.
          _print_line "[${_index}] ${_filename}"
        fi

        _hit="$(printf "%s\n" "${_line}" | cut -d: -f 2-)"
        printf "%s\n\n" "${_hit}"
      fi

      _last_path="${_path}"
    done
  fi
}

# show ########################################################################

# _show()
#
# Usage:
#   _show <selection>
_show() {
  _debug printf "_show() \$0: '%s'\n" "${0:-}"
  _debug printf "_show() \$1: '%s'\n" "${1:-}"
  _debug printf "_show() \$2: '%s'\n" "${2:-}"

  local -a _arguments=("${@:1}")
  local _selection=
  local _basename=
  local _render=0
  local _dump=0
  local _path=0

  _debug printf "_show() \$_arguments[*]: '%s'\n" "${_arguments[*]:-}"

  for _arg in "${_arguments[@]:-}"
  do
    case "${_arg}" in
      --dump)
        _dump=1
        ;;
      --path)
        _path=1
        ;;
      --render)
        _render=1
        ;;
      *)
        if [[ -z "${_selection}" ]]
        then
          _selection="${_arg}"
        fi
        ;;
    esac
  done

  _debug printf "_show() \$_render: '%s'\n" "${_render}"
  _debug printf "_show() \$_selection: '%s'\n" "${_selection}"

  # Determine file basename for the provided <selection>.
  if [[ -z "${_selection}" ]]
  then # <selection> is blank.
    $_ME help
    return 1
  elif [[ -e "${NOTES_DATA_DIR}/${_selection}" ]]
  then # <selection> is a filename.
    _basename="${_selection}"
  elif [[ "${_selection}" =~ ^[0-9]+$ ]]
  then # <selection> is an id.
    local _filenames=($(ls -r "${NOTES_DATA_DIR}"))
    _debug printf "_show() \$_filenames[*]: '%s'\n" "${_filenames[*]}"
    _basename="${_filenames[${_selection}]:-}"
  fi

  # Display file.
  if [[ -n "${_basename}" ]] && [[ -e "${NOTES_DATA_DIR}/${_basename}" ]]
  then # _basename is assigned and a note exists with that name.
    if ((_path))
    then # `notes show --path`
      printf "%s/%s\n" "${NOTES_DATA_DIR}" "${_basename}"
    elif ((_render)) &&
         ((_dump))   &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render --dump` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "lynx"
    then # `notes show --render` with `pandoc` and `lynx` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" | lynx -stdin
    elif ((_render)) &&
         _command_exists "pandoc" &&
         _command_exists "w3m"
    then # `notes show --render` with `pandoc` and `w3m` available.
      pandoc "${NOTES_DATA_DIR}/${_basename}" \
        | w3m -dump -T text/html \
        | "${PAGER}"
    else # default
      if ((_dump))
      then # `notes show --dump`
        cat "${NOTES_DATA_DIR}/${_basename}" \
          | _highlight_syntax_if_available
      else # `notes show`
        cat "${NOTES_DATA_DIR}/${_basename}" \
          | _highlight_syntax_if_available \
          | "$PAGER"
      fi
    fi
  else # _basename is not assigned or no note exists with that name.
    _die printf "Selection not found.\n"
  fi
}

# status ######################################################################

# _status()
#
# Usage:
#   _status
_status() {
  cd "${NOTES_DATA_DIR}" || _die printf "_status() \`cd\` failed.\n"
  git status
}

# sync ########################################################################

# _sync()
#
# Usage:
#   _sync
_sync() {
  printf "Syncing..."
  (NOTES_AUTO_SYNC=1 _git_checkpoint "[NOTES] Sync commit." --spinner) &&
    printf "Done!\n---------------\n" ||
    printf "Syncing failed!\n"
}

# version ####################################################################

# _version()
#
# Usage:
#   _version
#
# Print the value of $_VERSION.
_version() {
  printf "%s\n" "$_VERSION"
}

###############################################################################
# _notes()
###############################################################################

# _notes()
#
# Description:
#   Call the appropriate subcommand.
_notes() {
  _debug printf "_notes() >> start\n"
  _debug printf "_notes() \${_ARGUMENTS[@]:1}: '%s'\n" "${_ARGUMENTS[@]:1}"

  case "$_SUBCOMMAND" in
    init)
      _git_required
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
    help|version)
      "_${_SUBCOMMAND}"
      ;;
    *)
      _git_required
      if [[ ! -e "${NOTES_DATA_DIR}" ]]
      then # `$NOTES_DATA_DIR` doesn't exist.
        _die cat <<HEREDOC
$NOTES_DATA_DIR doesn't exist. Use \`$_ME init\` to get started.
Usage: $_ME init [<remote url>]
HEREDOC
      fi
      if ((NOTES_AUTO_SYNC)) &&
         [[ "${_SUBCOMMAND}" =~ add|delete|edit|list|ls|show|search ]]
      then
        if _git_is_dirty
        then
          $_ME sync
        else
          ($_ME sync &>/dev/null) &
        fi
      fi
      "_${_SUBCOMMAND}" "${_ARGUMENTS[@]:1}"
      ;;
  esac
}

###############################################################################
# Main
###############################################################################

_main() {
  if (("$_PRINT_HELP"))
  then
    _help
  elif (("$_PRINT_VERSION"))
  then
    _version
  else
    _notes "${_ARGUMENTS[@]:-}"
  fi
}

_main "$@"
